{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is this? This is my writeups and tools for different CTFs i have participated.","title":"Home"},{"location":"#what-is-this","text":"This is my writeups and tools for different CTFs i have participated.","title":"What is this?"},{"location":"damncon%20ctf/","text":"Damncon CTF Writeup Web Go7 C00k3D Flag: DSPH{1_g07_c00kie5} This challenge was an easy one. So as the name suggests the challenge is about cookies. So I viewed the cookies and there was a cookie named Admin which was set to False . So I simply edited it to True and got the flag. Reversing Easy_but_not_blood Flag: DSPH{You_are_ON_UPSS} This was so an easy one. I ran the strings command on the program they gave and got the flag. strings rev DSPH{You_are_ ON_UPSS} ;*3$\" DSPH{YOU_ARE_FOOL} GCC: (Debian 10.2.1-6) 10.2.1 20210110","title":"Damncon CTF"},{"location":"damncon%20ctf/#damncon-ctf-writeup","text":"","title":"Damncon CTF Writeup"},{"location":"damncon%20ctf/#web","text":"","title":"Web"},{"location":"damncon%20ctf/#go7-c00k3d","text":"Flag: DSPH{1_g07_c00kie5} This challenge was an easy one. So as the name suggests the challenge is about cookies. So I viewed the cookies and there was a cookie named Admin which was set to False . So I simply edited it to True and got the flag.","title":"Go7 C00k3D"},{"location":"damncon%20ctf/#reversing","text":"","title":"Reversing"},{"location":"damncon%20ctf/#easy_but_not_blood","text":"Flag: DSPH{You_are_ON_UPSS} This was so an easy one. I ran the strings command on the program they gave and got the flag. strings rev DSPH{You_are_ ON_UPSS} ;*3$\" DSPH{YOU_ARE_FOOL} GCC: (Debian 10.2.1-6) 10.2.1 20210110","title":"Easy_but_not_blood"},{"location":"fweefwop/","text":"Fweefwop CTF Writeup General Base2 Flag: 11101000 Description What is 0xe8 in binary? (use 8 bits) The number given to us is in hex. So we can convert it into binary using python >> f \" { 0xe8 : 0b } \" '11101000' Base64 Abridged Flag: SSBsb3ZlIENURgo= Description What is the result of base64 encoding of \"I love CTF\"? We can use the `base64` command for encoding this into base64 echo \"I love CTF\" | base64 Hex the way in Flag: fwopCTF{back_from_hex} Description 66 77 6f 70 43 54 46 7b 62 61 63 6b 5f 66 72 6f 6d 5f 68 65 78 7d If you have played CTFs before you know this is hex. So just decode it. I ran it in bash using the command called unhex and got the output fwopCTF{back_from_hex} unhex 66 77 6f 70 43 54 46 7b 62 61 63 6b 5f 66 72 6f 6d 5f 68 65 78 7d Touch the base Flag: fwopCTF{base64_is_everywhere} Description ZndvcENURntiYXNlNjRfaXNfZXZlcnl3aGVyZX0= That is clearly base64. We can use the same tool used in Base64 Abridged . To decode the base64 we will need to add a -d flag at the end of that tool. And if we run it then we will get the flag fwopCTF{base64_is_everywhere} . echo \"ZndvcENURntiYXNlNjRfaXNfZXZlcnl3aGVyZX0=\" | base64 -d Crypto Silly Secret Sharing Flag: 84333 For this challenge I read a article in wikipedia and took a code from there, and then modified the code a bit and ran it. And tada! you get the flag! Wikipedia article on Shamir's Secret Sharing Here's the code: _PRIME = 2 ** 127 - 1 def _extended_gcd ( a , b ): \"\"\" Division in integers modulus p means finding the inverse of the denominator modulo p and then multiplying the numerator by this inverse (Note: inverse of A is B such that A*B % p == 1) this can be computed via extended Euclidean algorithm http://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Computation \"\"\" x = 0 last_x = 1 y = 1 last_y = 0 while b != 0 : quot = a // b a , b = b , a % b x , last_x = last_x - quot * x , x y , last_y = last_y - quot * y , y return last_x , last_y def _divmod ( num , den , p ): \"\"\"Compute num / den modulo prime p To explain what this means, the return value will be such that the following is true: den * _divmod(num, den, p) % p == num \"\"\" inv , _ = _extended_gcd ( den , p ) return num * inv def _lagrange_interpolate ( x , x_s , y_s , p ): \"\"\" Find the y-value for the given x, given n (x, y) points; k points will define a polynomial of up to kth order. \"\"\" k = len ( x_s ) assert k == len ( set ( x_s )), \"points must be distinct\" def PI ( vals ): # upper-case PI -- product of inputs accum = 1 for v in vals : accum *= v return accum nums = [] # avoid inexact division dens = [] for i in range ( k ): others = list ( x_s ) cur = others . pop ( i ) nums . append ( PI ( x - o for o in others )) dens . append ( PI ( cur - o for o in others )) den = PI ( dens ) num = sum ([ _divmod ( nums [ i ] * den * y_s [ i ] % p , dens [ i ], p ) for i in range ( k )]) return ( _divmod ( num , den , p ) + p ) % p def recover_secret ( shares , prime = _PRIME ): \"\"\" Recover the secret from share points (x, y points on the polynomial). \"\"\" if len ( shares ) < 2 : raise ValueError ( \"need at least two shares\" ) x_s , y_s = zip ( * shares ) return _lagrange_interpolate ( 0 , x_s , y_s , prime ) shares = [( 20 , 161013 ), ( 10 , 122673 )] print ( recover_secret ( shares )) Open Secret Flag: fwopCTF{I_found_the_alien_his_name_is_paul} So first I read this article on Wikipedia about Diffie Hellman Key exchange. Then I calculated s and xored base64 decoded flag with the key as bytes represantation of s . Here's the code: from Crypto.Util.number import long_to_bytes import base64 from pwn import xor p = 824717393 g = 150357959 A = 734947628 b = 845023462 B = pow ( g , b , p ) s = pow ( A , b , p ) flag = 'T6ZBVGqFaF9gjkhLXL9Ke125S3tIvUdBR45GTVqOQEVEtHFNWo5eRVy9Uw==' print ( xor ( base64 . b64decode ( flag ), long_to_bytes ( s ))) Pretty Safe Password Flag: fwopCTF{pa55word} For this challenge I wrapped all of the passwords with fwopCTF{} in sublime text. Then I ran John the ripper on the hash using the following command: $ john hash.txt --wordlist = 10k-most-common.txt --format = Raw-MD5 Web SQLI Flag: fwopCTF{Leaked_data_123} This challenge was just a basic SQL injection. I got the flag by just passing ' OR 1=1 -- as both password and username. SQLI But Filtered? Flag: fwopCTF{f1lt3rs_not_good_3n0ugh} This challenge is just advanced version of the SQLI Challenge. So First I tried the payload on that challenge but it didn't work. So I tried more of them and finally the ' || '1'='1 as admin and password got me the flag. Reversing Reversing Python 1 Flag: fwopCTF{no_python_required} Code given with the challenge: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () if enteredFlag == \"fwopCTF {no_python_required} \" : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) The flag is right there in the if check. You can just submit that as the flag. Reversing Python 2 Flag: fwopCTF{perhaps_this_is_the_flag} Code given with the challenge: var1 = \"fwopCTF {this_might_be_the_flag} \" var2 = \"fwopCTF {this_could_be_the_flag} \" var3 = \"fwopCTF {this_potentially_is_the_flag} \" var4 = \"fwopCTF {perhaps_this_is_the_flag} \" var5 = \"fwopCTF{could_this_be_the_flag?}\" var6 = \"fwopCTF{this_probably_isn't_the_flag}\" print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () if enteredFlag == var4 : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So the if block prints Your flag is correct! when the entered flag is equal to var4 . So we can copy the text in var4 and submit as the flag. Reversing Python 3 Flag: fwopCTF{see_seesaw_sheshore_see_sheshore_seasells_shells} Code given with the challenge: var1 = \"fwopCTF {sheshore_seasore_shells_seasore_shesore_seashells_seashore} \" var3 = \"fwopCTF {sheshore_seashore_seesaw_seesaw_shesore_seasore_seasells} \" var2 = \"fwopCTF {shesore_seashells_seashells_seasells_shells_seesaw_seasells} \" var1 = \"fwopCTF {seashore_see_seashells_shesore_seesaw_sheshore_shells} \" var3 = \"fwopCTF {seashells_shells_seasells_seasells_she_shells_see} \" var1 = \"fwopCTF {she_seasells_seashore_seashore_seasore_shells_seashore} \" var2 = \"fwopCTF {seasore_shells_shells_seashells_sheshore_she_seasells} \" var3 = \"fwopCTF {seasore_seesaw_see_seashore_seashells_seashore_seesaw} \" var3 = \"fwopCTF {see_seesaw_sheshore_see_sheshore_seasells_shells} \" var1 = \"fwopCTF {seashells_she_seasore_seashore_shesore_shesore_seasells} \" var2 = \"fwopCTF {seasells_seashells_shesore_seasore_seasore_sheshore_seasore} \" var1 = \"fwopCTF {she_seesaw_she_seashore_seasells_she_seesaw} \" var1 = \"fwopCTF {she_seashore_shesore_sheshore_sheshore_seesaw_she} \" var2 = \"fwopCTF {seasells_she_seasore_she_seashore_seashore_seashells} \" var1 = \"fwopCTF {shesore_see_see_seesaw_sheshore_seashells_seashells} \" print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () if enteredFlag == var3 : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So in this challenge the if block checks if the entered text is equal to var3 And we can see that var3 has changed many times in the code. So we can basically just copy the text in the last occurence of var3 which is fwopCTF{see_seesaw_sheshore_see_sheshore_seasells_shells} and we can submit that as the flag. Reversing Python 4 Flag: fwopCTF{then_if_then_else_if_if} Code given with this challenge: print ( \"Enter the flag and I will check it for you.\" ) enteredflag = input () var1 = 15 var2 = 4 var3 = 9 if var1 < var3 : var2 = var1 + var3 elif var3 > var2 : var1 = ( var1 * var2 ) - var2 else : var3 = var2 * var1 if var1 - var2 * var3 >= 10 : var1 = 15 - var3 var3 = var1 * var2 else : var2 = var1 / var2 var3 = var3 * 2 if var1 + var2 > var3 : if var2 + 2 != var1 : correctflag = \"fwopCTF {else_elif_if_elif_else_else} \" elif var3 - var1 >= var2 * var2 : correctflag = \"fwopCTF {else_if_then_then_else_elif} \" elif var3 + var1 + var2 <= var3 + var1 * var2 : correctflag = \"fwopCTF {then_else_else_then_if_if} \" var3 = ( var3 * - 1 ) + var1 + var2 if var3 + var2 + var1 * 2 >= 0 : if var3 == var2 * - 2 : correctflag = \"fwopCTF {else_then_if_then_elif_elif} \" elif var2 * var1 - var3 == 3 * var1 + 5 * var2 : correctflag = \"fwopCTF {then_if_then_else_if_if} \" else : correctflag = \"fwopCTF {elif_if_if_then_elif_elif} \" if enteredflag == correctflag : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So we can see that there is so many things goin on here. But we can ignore them all and just focus near the if statement. So we can see that if the entered text is equal to correctflag then it print Your flag is correct! . So we can printthe correctflag variable just before the if statement and thus we get the flag fwopCTF{then_if_then_else_if_if} by inputting anything. # if enteredflag == correctflag: # print(\"Your flag is correct!\") # else: # print(\"Your flag is incorrect. :(\") print ( correctflag ) Reversing Python 5 Flag: fwopCTF{bonucleicryxriluoxe} Code given with the challenge: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () correctflag = \"deoxyribonucleic_acid\" correctflag = correctflag [ 0 : 4 ] + correctflag [ 7 : 16 ] + correctflag [ 5 : 2 : - 1 ] correctflag = correctflag [ 4 : - 4 ] + correctflag [ 3 * 4 : - 1 ] + correctflag [ - 1 : 0 : - 2 ] if enteredFlag == correctflag : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) Same trick as Reversing Python 4 . Comment the if statement and then print correctflag and wrap it with fwopCTF{} . # if enteredFlag == correctflag: # print(\"Your flag is correct!\") # else: # print(\"Your flag is incorrect. :(\") print ( correctflag ) Reversing Python 6 Flag: fwopCTF{also_crypto_lol} Code given with the challenge: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () alphabet = \"abcdefghijklmnopqrstuvwxyz {} _ABCDEFGHIJKLMNOPQRSTUVWXYZ\" code = [ 5 , 22 , 14 , 15 , 31 , 48 , 34 , 26 , 0 , 11 , 18 , 14 , 28 , 2 , 17 , 24 , 15 , 19 , 14 , 28 , 11 , 14 , 11 , 27 ] correctflag = \"\" for currentNum in code : correctflag = correctflag + alphabet [ currentNum ] if enteredFlag == correctflag : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) This is also same as Reversing Python 4 and Reversing Python 5 . Just print the correctflag # if enteredFlag == correctflag: # print(\"Your flag is correct!\") # else: # print(\"Your flag is incorrect. :(\") print ( correctflag ) Reversing Python 7 Flag: its_time_t;qfwopCTF{ Code which we need to reverse: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () semicolonpos = 0 fail = False if len ( enteredFlag ) != 20 : print ( \"Your flag is incorrect. :(\" ) else : enteredFlag = enteredFlag [ 12 : 20 ] + enteredFlag [ 0 : 12 ] for i in range ( 20 ): if enteredFlag [ i ] == \";\" : semicolonpos = i elif enteredFlag [ i ] == \"q\" : break ; else : fail = True if not fail : enteredFlag = enteredFlag [ 0 : semicolonpos ] + \"o_dddduel}\" if enteredFlag == \"fwopCTF {its_time_to_dddduel} \" : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So first of all we can see the that they are adding o_dddduel} to the flag. So the first part of the flag will be fwopCTF{its_time_t . Then we can see that it removes the semi colon from the entered input. so we can add that and now the flag will look lik fwopCTF{its_time_; . And if let's take a look at the for loop. We can see that it will break if the letter q is occured. So we now can add that also, and the flag will be fwopCTF{its_time_;q . and the final step is to shuffle them. So to reverse that we can use string splicing in python. Using the python code flag[8:]+flag[:8] we can see that the flag will be its_time_t;qfwopCTF{ and that's it we got the flag! Here's the code for that: # The flag checked in the if statement flag = \"fwopCTF {its_time_to_dddduel} \" # Where the semicolon was semicolonpos = 18 # Cut upto the semicolon and then add the semicolon and q flag = flag [ 0 : semicolonpos ] + \";q\" # Now shuffle it shuffled_flag = flag [ 8 :] + flag [: 8 ] # And finally print wthe result print ( shuffled_flag )","title":"Fweefwop CTF"},{"location":"fweefwop/#fweefwop-ctf-writeup","text":"","title":"Fweefwop CTF Writeup"},{"location":"fweefwop/#general","text":"","title":"General"},{"location":"fweefwop/#base2","text":"Flag: 11101000 Description What is 0xe8 in binary? (use 8 bits) The number given to us is in hex. So we can convert it into binary using python >> f \" { 0xe8 : 0b } \" '11101000'","title":"Base2"},{"location":"fweefwop/#base64-abridged","text":"Flag: SSBsb3ZlIENURgo= Description What is the result of base64 encoding of \"I love CTF\"? We can use the `base64` command for encoding this into base64 echo \"I love CTF\" | base64","title":"Base64 Abridged"},{"location":"fweefwop/#hex-the-way-in","text":"Flag: fwopCTF{back_from_hex} Description 66 77 6f 70 43 54 46 7b 62 61 63 6b 5f 66 72 6f 6d 5f 68 65 78 7d If you have played CTFs before you know this is hex. So just decode it. I ran it in bash using the command called unhex and got the output fwopCTF{back_from_hex} unhex 66 77 6f 70 43 54 46 7b 62 61 63 6b 5f 66 72 6f 6d 5f 68 65 78 7d","title":"Hex the way in"},{"location":"fweefwop/#touch-the-base","text":"Flag: fwopCTF{base64_is_everywhere} Description ZndvcENURntiYXNlNjRfaXNfZXZlcnl3aGVyZX0= That is clearly base64. We can use the same tool used in Base64 Abridged . To decode the base64 we will need to add a -d flag at the end of that tool. And if we run it then we will get the flag fwopCTF{base64_is_everywhere} . echo \"ZndvcENURntiYXNlNjRfaXNfZXZlcnl3aGVyZX0=\" | base64 -d","title":"Touch the base"},{"location":"fweefwop/#crypto","text":"","title":"Crypto"},{"location":"fweefwop/#silly-secret-sharing","text":"Flag: 84333 For this challenge I read a article in wikipedia and took a code from there, and then modified the code a bit and ran it. And tada! you get the flag! Wikipedia article on Shamir's Secret Sharing Here's the code: _PRIME = 2 ** 127 - 1 def _extended_gcd ( a , b ): \"\"\" Division in integers modulus p means finding the inverse of the denominator modulo p and then multiplying the numerator by this inverse (Note: inverse of A is B such that A*B % p == 1) this can be computed via extended Euclidean algorithm http://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Computation \"\"\" x = 0 last_x = 1 y = 1 last_y = 0 while b != 0 : quot = a // b a , b = b , a % b x , last_x = last_x - quot * x , x y , last_y = last_y - quot * y , y return last_x , last_y def _divmod ( num , den , p ): \"\"\"Compute num / den modulo prime p To explain what this means, the return value will be such that the following is true: den * _divmod(num, den, p) % p == num \"\"\" inv , _ = _extended_gcd ( den , p ) return num * inv def _lagrange_interpolate ( x , x_s , y_s , p ): \"\"\" Find the y-value for the given x, given n (x, y) points; k points will define a polynomial of up to kth order. \"\"\" k = len ( x_s ) assert k == len ( set ( x_s )), \"points must be distinct\" def PI ( vals ): # upper-case PI -- product of inputs accum = 1 for v in vals : accum *= v return accum nums = [] # avoid inexact division dens = [] for i in range ( k ): others = list ( x_s ) cur = others . pop ( i ) nums . append ( PI ( x - o for o in others )) dens . append ( PI ( cur - o for o in others )) den = PI ( dens ) num = sum ([ _divmod ( nums [ i ] * den * y_s [ i ] % p , dens [ i ], p ) for i in range ( k )]) return ( _divmod ( num , den , p ) + p ) % p def recover_secret ( shares , prime = _PRIME ): \"\"\" Recover the secret from share points (x, y points on the polynomial). \"\"\" if len ( shares ) < 2 : raise ValueError ( \"need at least two shares\" ) x_s , y_s = zip ( * shares ) return _lagrange_interpolate ( 0 , x_s , y_s , prime ) shares = [( 20 , 161013 ), ( 10 , 122673 )] print ( recover_secret ( shares ))","title":"Silly Secret Sharing"},{"location":"fweefwop/#open-secret","text":"Flag: fwopCTF{I_found_the_alien_his_name_is_paul} So first I read this article on Wikipedia about Diffie Hellman Key exchange. Then I calculated s and xored base64 decoded flag with the key as bytes represantation of s . Here's the code: from Crypto.Util.number import long_to_bytes import base64 from pwn import xor p = 824717393 g = 150357959 A = 734947628 b = 845023462 B = pow ( g , b , p ) s = pow ( A , b , p ) flag = 'T6ZBVGqFaF9gjkhLXL9Ke125S3tIvUdBR45GTVqOQEVEtHFNWo5eRVy9Uw==' print ( xor ( base64 . b64decode ( flag ), long_to_bytes ( s )))","title":"Open Secret"},{"location":"fweefwop/#pretty-safe-password","text":"Flag: fwopCTF{pa55word} For this challenge I wrapped all of the passwords with fwopCTF{} in sublime text. Then I ran John the ripper on the hash using the following command: $ john hash.txt --wordlist = 10k-most-common.txt --format = Raw-MD5","title":"Pretty Safe Password"},{"location":"fweefwop/#web","text":"","title":"Web"},{"location":"fweefwop/#sqli","text":"Flag: fwopCTF{Leaked_data_123} This challenge was just a basic SQL injection. I got the flag by just passing ' OR 1=1 -- as both password and username.","title":"SQLI"},{"location":"fweefwop/#sqli-but-filtered","text":"Flag: fwopCTF{f1lt3rs_not_good_3n0ugh} This challenge is just advanced version of the SQLI Challenge. So First I tried the payload on that challenge but it didn't work. So I tried more of them and finally the ' || '1'='1 as admin and password got me the flag.","title":"SQLI But Filtered?"},{"location":"fweefwop/#reversing","text":"","title":"Reversing"},{"location":"fweefwop/#reversing-python-1","text":"Flag: fwopCTF{no_python_required} Code given with the challenge: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () if enteredFlag == \"fwopCTF {no_python_required} \" : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) The flag is right there in the if check. You can just submit that as the flag.","title":"Reversing Python 1"},{"location":"fweefwop/#reversing-python-2","text":"Flag: fwopCTF{perhaps_this_is_the_flag} Code given with the challenge: var1 = \"fwopCTF {this_might_be_the_flag} \" var2 = \"fwopCTF {this_could_be_the_flag} \" var3 = \"fwopCTF {this_potentially_is_the_flag} \" var4 = \"fwopCTF {perhaps_this_is_the_flag} \" var5 = \"fwopCTF{could_this_be_the_flag?}\" var6 = \"fwopCTF{this_probably_isn't_the_flag}\" print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () if enteredFlag == var4 : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So the if block prints Your flag is correct! when the entered flag is equal to var4 . So we can copy the text in var4 and submit as the flag.","title":"Reversing Python 2"},{"location":"fweefwop/#reversing-python-3","text":"Flag: fwopCTF{see_seesaw_sheshore_see_sheshore_seasells_shells} Code given with the challenge: var1 = \"fwopCTF {sheshore_seasore_shells_seasore_shesore_seashells_seashore} \" var3 = \"fwopCTF {sheshore_seashore_seesaw_seesaw_shesore_seasore_seasells} \" var2 = \"fwopCTF {shesore_seashells_seashells_seasells_shells_seesaw_seasells} \" var1 = \"fwopCTF {seashore_see_seashells_shesore_seesaw_sheshore_shells} \" var3 = \"fwopCTF {seashells_shells_seasells_seasells_she_shells_see} \" var1 = \"fwopCTF {she_seasells_seashore_seashore_seasore_shells_seashore} \" var2 = \"fwopCTF {seasore_shells_shells_seashells_sheshore_she_seasells} \" var3 = \"fwopCTF {seasore_seesaw_see_seashore_seashells_seashore_seesaw} \" var3 = \"fwopCTF {see_seesaw_sheshore_see_sheshore_seasells_shells} \" var1 = \"fwopCTF {seashells_she_seasore_seashore_shesore_shesore_seasells} \" var2 = \"fwopCTF {seasells_seashells_shesore_seasore_seasore_sheshore_seasore} \" var1 = \"fwopCTF {she_seesaw_she_seashore_seasells_she_seesaw} \" var1 = \"fwopCTF {she_seashore_shesore_sheshore_sheshore_seesaw_she} \" var2 = \"fwopCTF {seasells_she_seasore_she_seashore_seashore_seashells} \" var1 = \"fwopCTF {shesore_see_see_seesaw_sheshore_seashells_seashells} \" print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () if enteredFlag == var3 : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So in this challenge the if block checks if the entered text is equal to var3 And we can see that var3 has changed many times in the code. So we can basically just copy the text in the last occurence of var3 which is fwopCTF{see_seesaw_sheshore_see_sheshore_seasells_shells} and we can submit that as the flag.","title":"Reversing Python 3"},{"location":"fweefwop/#reversing-python-4","text":"Flag: fwopCTF{then_if_then_else_if_if} Code given with this challenge: print ( \"Enter the flag and I will check it for you.\" ) enteredflag = input () var1 = 15 var2 = 4 var3 = 9 if var1 < var3 : var2 = var1 + var3 elif var3 > var2 : var1 = ( var1 * var2 ) - var2 else : var3 = var2 * var1 if var1 - var2 * var3 >= 10 : var1 = 15 - var3 var3 = var1 * var2 else : var2 = var1 / var2 var3 = var3 * 2 if var1 + var2 > var3 : if var2 + 2 != var1 : correctflag = \"fwopCTF {else_elif_if_elif_else_else} \" elif var3 - var1 >= var2 * var2 : correctflag = \"fwopCTF {else_if_then_then_else_elif} \" elif var3 + var1 + var2 <= var3 + var1 * var2 : correctflag = \"fwopCTF {then_else_else_then_if_if} \" var3 = ( var3 * - 1 ) + var1 + var2 if var3 + var2 + var1 * 2 >= 0 : if var3 == var2 * - 2 : correctflag = \"fwopCTF {else_then_if_then_elif_elif} \" elif var2 * var1 - var3 == 3 * var1 + 5 * var2 : correctflag = \"fwopCTF {then_if_then_else_if_if} \" else : correctflag = \"fwopCTF {elif_if_if_then_elif_elif} \" if enteredflag == correctflag : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So we can see that there is so many things goin on here. But we can ignore them all and just focus near the if statement. So we can see that if the entered text is equal to correctflag then it print Your flag is correct! . So we can printthe correctflag variable just before the if statement and thus we get the flag fwopCTF{then_if_then_else_if_if} by inputting anything. # if enteredflag == correctflag: # print(\"Your flag is correct!\") # else: # print(\"Your flag is incorrect. :(\") print ( correctflag )","title":"Reversing Python 4"},{"location":"fweefwop/#reversing-python-5","text":"Flag: fwopCTF{bonucleicryxriluoxe} Code given with the challenge: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () correctflag = \"deoxyribonucleic_acid\" correctflag = correctflag [ 0 : 4 ] + correctflag [ 7 : 16 ] + correctflag [ 5 : 2 : - 1 ] correctflag = correctflag [ 4 : - 4 ] + correctflag [ 3 * 4 : - 1 ] + correctflag [ - 1 : 0 : - 2 ] if enteredFlag == correctflag : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) Same trick as Reversing Python 4 . Comment the if statement and then print correctflag and wrap it with fwopCTF{} . # if enteredFlag == correctflag: # print(\"Your flag is correct!\") # else: # print(\"Your flag is incorrect. :(\") print ( correctflag )","title":"Reversing Python 5"},{"location":"fweefwop/#reversing-python-6","text":"Flag: fwopCTF{also_crypto_lol} Code given with the challenge: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () alphabet = \"abcdefghijklmnopqrstuvwxyz {} _ABCDEFGHIJKLMNOPQRSTUVWXYZ\" code = [ 5 , 22 , 14 , 15 , 31 , 48 , 34 , 26 , 0 , 11 , 18 , 14 , 28 , 2 , 17 , 24 , 15 , 19 , 14 , 28 , 11 , 14 , 11 , 27 ] correctflag = \"\" for currentNum in code : correctflag = correctflag + alphabet [ currentNum ] if enteredFlag == correctflag : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) This is also same as Reversing Python 4 and Reversing Python 5 . Just print the correctflag # if enteredFlag == correctflag: # print(\"Your flag is correct!\") # else: # print(\"Your flag is incorrect. :(\") print ( correctflag )","title":"Reversing Python 6"},{"location":"fweefwop/#reversing-python-7","text":"Flag: its_time_t;qfwopCTF{ Code which we need to reverse: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () semicolonpos = 0 fail = False if len ( enteredFlag ) != 20 : print ( \"Your flag is incorrect. :(\" ) else : enteredFlag = enteredFlag [ 12 : 20 ] + enteredFlag [ 0 : 12 ] for i in range ( 20 ): if enteredFlag [ i ] == \";\" : semicolonpos = i elif enteredFlag [ i ] == \"q\" : break ; else : fail = True if not fail : enteredFlag = enteredFlag [ 0 : semicolonpos ] + \"o_dddduel}\" if enteredFlag == \"fwopCTF {its_time_to_dddduel} \" : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So first of all we can see the that they are adding o_dddduel} to the flag. So the first part of the flag will be fwopCTF{its_time_t . Then we can see that it removes the semi colon from the entered input. so we can add that and now the flag will look lik fwopCTF{its_time_; . And if let's take a look at the for loop. We can see that it will break if the letter q is occured. So we now can add that also, and the flag will be fwopCTF{its_time_;q . and the final step is to shuffle them. So to reverse that we can use string splicing in python. Using the python code flag[8:]+flag[:8] we can see that the flag will be its_time_t;qfwopCTF{ and that's it we got the flag! Here's the code for that: # The flag checked in the if statement flag = \"fwopCTF {its_time_to_dddduel} \" # Where the semicolon was semicolonpos = 18 # Cut upto the semicolon and then add the semicolon and q flag = flag [ 0 : semicolonpos ] + \";q\" # Now shuffle it shuffled_flag = flag [ 8 :] + flag [: 8 ] # And finally print wthe result print ( shuffled_flag )","title":"Reversing Python 7"},{"location":"tfc%20ctf/","text":"The Few Chosen(TFC) CTF Writeup Forensics AAAAA Flag: TFCCTF{Gr4phic_d35ign_is_my_p455ion} File given with this challenge: AAAAA I tried to look what file it was by running the file command. But it showed only data . So I checked it in hexedit and saw a bunch of A s in the beginning of the file and after those A s there was some interesting stuffs. So I ran foremost AAAAA and got the flag as a png file: Crypto Sea Language 1 Flag: TFCCTF{WH4T-AR3-Y0U-S1NK1NG-AB0UT?!!!?} Cipher given with the challenge: .-- .... ....- - -....- .- .-. ...-- -....- -.-- ----- ..- -....- ... .---- -. -.- .---- -. --. -....- .- -... ----- ..- - ..--.. -.-.-- -.-.-- -.-.-- ..--. I knew it was morse code just by looking at it. So I decoded it and got the flag. Sea Language 2 Flag: TFCCTF{w417_4_m1nu73..._7h15_1s_n07_m0rs3!!!!!r1gh7?} Cipher given with the challenge: ._._._.. ._...__. ._....__ ._....__ ._._._.. ._...__. .____.__ .___.___ ..__._.. ..__..._ ..__.___ ._._____ ..__._.. ._._____ .__.__._ ..__..._ .__.___. .___._._ ..__.___ ..__..__ .._.___. .._.___. .._.___. ._._____ ..__.___ .__._... ..__..._ ..__._._ ._._____ ..__..._ .___..__ ._._____ .__.___. ..__.... ..__.___ ._._____ .__.__._ ..__.... .___.._. .___..__ ..__..__ .._...._ .._...._ .._...._ .._...._ .._...._ .___.._. ..__..._ .__..___ .__._... ..__.___ ..______ ._____._ When I first looked at the cipher, I thought it was morse code, but I was wrong. After some thoughts, I found out that all of them are splitted by 8 characters, so I translated it into binary by replacing . with 0 and _ with 1 and then put it on an online decoder and got the flag. The below code will do the same: def binary_to_ascii ( binaryString ): return \"\" . join ([ chr ( int ( binaryString [ i : i + 8 ], 2 )) for i in range ( 0 , len ( binaryString ), 8 )]) encoded = \"\"\" ._._._.. ._...__. ._....__ ._....__ ._._._.. ._...__. .____.__ .___.___ ..__._.. ..__..._ ..__.___ ._._____ ..__._.. ._._____ .__.__._ ..__..._ .__.___. .___._._ ..__.___ ..__..__ .._.___. .._.___. .._.___. ._._____ ..__.___ .__._... ..__..._ ..__._._ ._._____ ..__..._ .___..__ ._._____ .__.___. ..__.... ..__.___ ._._____ .__.__._ ..__.... .___.._. .___..__ ..__..__ .._...._ .._...._ .._...._ .._...._ .._...._ .___.._. ..__..._ .__..___ .__._... ..__.___ ..______ ._____._ \"\"\" encoded = encoded . replace ( \".\" , \"0\" ) . replace ( \"_\" , \"1\" ) # Translating it into binary encoded = encoded . replace ( \" \" , \"\" ) . replace ( \" \\n \" , \"\" ) # Removing all the spaces and newline characters print ( binary_to_ascii ( encoded )) Holiday Flag: TFCCTF{don't_come_today_there_are_dogs} Description I've always wanted to visit my friend! He's not fluent in English, but he does know a few words. This made communicating a problem. We did, however, talk about each other a lot! He knows I'm allergic to dogs, and I know that his favourite colour is green! Before leaving for the airport, he left me a message. He's not much into technology so his crypted message really confused me!Can you tell me what he said? Maui: mai hele mai i k\u0113ia l\u0101 aia n\u0101 \u02bb\u012blio So I tried putting don't come today there are dogs into google translate and got this: don't come today there are dogs . So I tried changing this into the flag format by replacing spaces with underscores and got the flag! Misc Discord Shenanigans Flag: TFCCTF{th1s_5t3g0_fl4g_w45_n0t_h1dden_w3ll} Description We considered giving you a free flag. However, we decided against it. In general, we would never do that! Or would we? That's the beginning of a good CTF! Discord is the new Twitter. To be able to solve this challenge, you'll need to join our discord. Link in the Rules page. So many people used bot commands in the CTF's server, but that was not how you could get the flag. I had found a suspicious old message from the author of this challenge in the general channel. I googled so many decrypters for this but none I could find. Finally, a friend of mine gave me this link https://holloway.nz/steg/ which was a decoder for this message. So i took this message and put it in the decoder and got the flag!","title":"The Few Chosen CTF"},{"location":"tfc%20ctf/#the-few-chosentfc-ctf-writeup","text":"","title":"The Few Chosen(TFC) CTF Writeup"},{"location":"tfc%20ctf/#forensics","text":"","title":"Forensics"},{"location":"tfc%20ctf/#aaaaa","text":"Flag: TFCCTF{Gr4phic_d35ign_is_my_p455ion} File given with this challenge: AAAAA I tried to look what file it was by running the file command. But it showed only data . So I checked it in hexedit and saw a bunch of A s in the beginning of the file and after those A s there was some interesting stuffs. So I ran foremost AAAAA and got the flag as a png file:","title":"AAAAA"},{"location":"tfc%20ctf/#crypto","text":"","title":"Crypto"},{"location":"tfc%20ctf/#sea-language-1","text":"Flag: TFCCTF{WH4T-AR3-Y0U-S1NK1NG-AB0UT?!!!?} Cipher given with the challenge: .-- .... ....- - -....- .- .-. ...-- -....- -.-- ----- ..- -....- ... .---- -. -.- .---- -. --. -....- .- -... ----- ..- - ..--.. -.-.-- -.-.-- -.-.-- ..--. I knew it was morse code just by looking at it. So I decoded it and got the flag.","title":"Sea Language 1"},{"location":"tfc%20ctf/#sea-language-2","text":"Flag: TFCCTF{w417_4_m1nu73..._7h15_1s_n07_m0rs3!!!!!r1gh7?} Cipher given with the challenge: ._._._.. ._...__. ._....__ ._....__ ._._._.. ._...__. .____.__ .___.___ ..__._.. ..__..._ ..__.___ ._._____ ..__._.. ._._____ .__.__._ ..__..._ .__.___. .___._._ ..__.___ ..__..__ .._.___. .._.___. .._.___. ._._____ ..__.___ .__._... ..__..._ ..__._._ ._._____ ..__..._ .___..__ ._._____ .__.___. ..__.... ..__.___ ._._____ .__.__._ ..__.... .___.._. .___..__ ..__..__ .._...._ .._...._ .._...._ .._...._ .._...._ .___.._. ..__..._ .__..___ .__._... ..__.___ ..______ ._____._ When I first looked at the cipher, I thought it was morse code, but I was wrong. After some thoughts, I found out that all of them are splitted by 8 characters, so I translated it into binary by replacing . with 0 and _ with 1 and then put it on an online decoder and got the flag. The below code will do the same: def binary_to_ascii ( binaryString ): return \"\" . join ([ chr ( int ( binaryString [ i : i + 8 ], 2 )) for i in range ( 0 , len ( binaryString ), 8 )]) encoded = \"\"\" ._._._.. ._...__. ._....__ ._....__ ._._._.. ._...__. .____.__ .___.___ ..__._.. ..__..._ ..__.___ ._._____ ..__._.. ._._____ .__.__._ ..__..._ .__.___. .___._._ ..__.___ ..__..__ .._.___. .._.___. .._.___. ._._____ ..__.___ .__._... ..__..._ ..__._._ ._._____ ..__..._ .___..__ ._._____ .__.___. ..__.... ..__.___ ._._____ .__.__._ ..__.... .___.._. .___..__ ..__..__ .._...._ .._...._ .._...._ .._...._ .._...._ .___.._. ..__..._ .__..___ .__._... ..__.___ ..______ ._____._ \"\"\" encoded = encoded . replace ( \".\" , \"0\" ) . replace ( \"_\" , \"1\" ) # Translating it into binary encoded = encoded . replace ( \" \" , \"\" ) . replace ( \" \\n \" , \"\" ) # Removing all the spaces and newline characters print ( binary_to_ascii ( encoded ))","title":"Sea Language 2"},{"location":"tfc%20ctf/#holiday","text":"Flag: TFCCTF{don't_come_today_there_are_dogs} Description I've always wanted to visit my friend! He's not fluent in English, but he does know a few words. This made communicating a problem. We did, however, talk about each other a lot! He knows I'm allergic to dogs, and I know that his favourite colour is green! Before leaving for the airport, he left me a message. He's not much into technology so his crypted message really confused me!Can you tell me what he said? Maui: mai hele mai i k\u0113ia l\u0101 aia n\u0101 \u02bb\u012blio So I tried putting don't come today there are dogs into google translate and got this: don't come today there are dogs . So I tried changing this into the flag format by replacing spaces with underscores and got the flag!","title":"Holiday"},{"location":"tfc%20ctf/#misc","text":"","title":"Misc"},{"location":"tfc%20ctf/#discord-shenanigans","text":"Flag: TFCCTF{th1s_5t3g0_fl4g_w45_n0t_h1dden_w3ll} Description We considered giving you a free flag. However, we decided against it. In general, we would never do that! Or would we? That's the beginning of a good CTF! Discord is the new Twitter. To be able to solve this challenge, you'll need to join our discord. Link in the Rules page. So many people used bot commands in the CTF's server, but that was not how you could get the flag. I had found a suspicious old message from the author of this challenge in the general channel. I googled so many decrypters for this but none I could find. Finally, a friend of mine gave me this link https://holloway.nz/steg/ which was a decoder for this message. So i took this message and put it in the decoder and got the flag!","title":"Discord Shenanigans"},{"location":"tools%20and%20commands/","text":"CTF Blader This is a listing of tools and commands that may help with CTF challenges. Crypto Caesar Cipher Caesar Cipher is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on. The method is named after Julius Caesar, who used it in his private correspondence. And here is a good online decoder for that . There is also a tool in linux for caesar cipher called caesar . More Info Rot13 ROT13 (\"rotate by 13 places\", sometimes hyphenated ROT-13) is a simple letter substitution cipher that replaces a letter with the 13 th letter after it in the alphabet. This is same as doing caesar cipher with 13 as the key. There are multiple variants for this like: rot47 , rot5 . More Info Rot47 ROT47 is a derivative of ROT13 which, in addition to scrambling the basic letters, treats numbers and common symbols. Instead of using the sequence A\u2013Z as the alphabet, ROT47 uses a larger set of characters from the common character encoding known as ASCII. Specifically, the 7-bit printable characters, excluding space, from decimal 33 '!' through 126 '~', 94 in total, taken in the order of the numerical values of their ASCII codes, are rotated by 47 positions, without special consideration of case. For example, the character A is mapped to p, while a is mapped to 2. The use of a larger alphabet produces a more thorough obfuscation than that of ROT13. For example: The Quick Brown Fox Jumps Over The Lazy Dog. enciphers to: %96 \"F:4< qC@H? u@I yF>AD ~G6C %96 {2KJ s@8] Here is a decoder for Rot47 Maritime Flags A maritime flag is a flag designated for use on ships, boats, and other watercraft. But it also comes often in puzzles and CTF challenges. Here is a decoder for Mary time flags . Birds on wire The encryption composed of birds represented as perched on an electric wire is in fact an alphabet of substitution by drawings (of the birds). Each bird represents a letter of the Latin alphabet (26 letters from A to Z) according to the correspondence. Here is a decoder . Miscellaneous Esoteric Languages Some of the most used esoteric languages are here. For more of them you can visit esolangs.org or view the list of some esolangs here . And for a place to run these esoteric languages you can try tio.run Brainfuck Brainfuck is an esoteric programming language created in 1993 by Urban M\u00fcller. Notable for its extreme minimalism, the language consists of only eight simple commands, a data pointer and an instruction pointer. While it is fully Turing complete, it is not intended for practical use, but to challenge and amuse programmers. Brainfuck simply requires one to break commands into microscopic steps. It's common to use brainfuck in CTF challenges. Hello world in brainfuck will look like: >++++++++[<+++++++++>-]<.>++++[<+++++++>-]<+.+++++++..+++.>>++++++[<+++++++>-]<+ +.------------.>++++++[<+++++++++>-]<+.<.+++.------.--------.>>>++++[<++++++++>- ]<+. More Info Interpreter Malbolge Malbolge is a public domain esoteric programming language invented by Ben Olmstead in 1998, named after the eighth circle of hell in Dante's Inferno, the Malebolge. It was specifically designed to be almost impossible to use, via a counter-intuitive 'crazy operation', base-three arithmetic, and self-altering code. It's common to misunderstand malbolge as base85 or rot47 Hello world in malbolge will look like: (=<`#9]~6ZY32Vx/4Rs+0No-&Jk)\"Fh}|Bcy?`=*z]Kw%oG4UUS0/@-ejc(:'8dc More Info Interpreter Piet Piet is a language designed by David Morgan-Mar, whose programs are bitmaps that look like abstract art. The compilation is guided by a \"pointer\" that moves around the image, from one continuous coloured region to the next. Procedures are carried through when the pointer exits a region. Hello world in Piet will look like: More Info Interpreter","title":"Tools and Commands"},{"location":"tools%20and%20commands/#ctf-blader","text":"This is a listing of tools and commands that may help with CTF challenges.","title":"CTF Blader"},{"location":"tools%20and%20commands/#crypto","text":"","title":"Crypto"},{"location":"tools%20and%20commands/#caesar-cipher","text":"Caesar Cipher is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on. The method is named after Julius Caesar, who used it in his private correspondence. And here is a good online decoder for that . There is also a tool in linux for caesar cipher called caesar . More Info","title":"Caesar Cipher"},{"location":"tools%20and%20commands/#rot13","text":"ROT13 (\"rotate by 13 places\", sometimes hyphenated ROT-13) is a simple letter substitution cipher that replaces a letter with the 13 th letter after it in the alphabet. This is same as doing caesar cipher with 13 as the key. There are multiple variants for this like: rot47 , rot5 . More Info","title":"Rot13"},{"location":"tools%20and%20commands/#rot47","text":"ROT47 is a derivative of ROT13 which, in addition to scrambling the basic letters, treats numbers and common symbols. Instead of using the sequence A\u2013Z as the alphabet, ROT47 uses a larger set of characters from the common character encoding known as ASCII. Specifically, the 7-bit printable characters, excluding space, from decimal 33 '!' through 126 '~', 94 in total, taken in the order of the numerical values of their ASCII codes, are rotated by 47 positions, without special consideration of case. For example, the character A is mapped to p, while a is mapped to 2. The use of a larger alphabet produces a more thorough obfuscation than that of ROT13. For example: The Quick Brown Fox Jumps Over The Lazy Dog. enciphers to: %96 \"F:4< qC@H? u@I yF>AD ~G6C %96 {2KJ s@8] Here is a decoder for Rot47","title":"Rot47"},{"location":"tools%20and%20commands/#maritime-flags","text":"A maritime flag is a flag designated for use on ships, boats, and other watercraft. But it also comes often in puzzles and CTF challenges. Here is a decoder for Mary time flags .","title":"Maritime Flags"},{"location":"tools%20and%20commands/#birds-on-wire","text":"The encryption composed of birds represented as perched on an electric wire is in fact an alphabet of substitution by drawings (of the birds). Each bird represents a letter of the Latin alphabet (26 letters from A to Z) according to the correspondence. Here is a decoder .","title":"Birds on wire"},{"location":"tools%20and%20commands/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"tools%20and%20commands/#esoteric-languages","text":"Some of the most used esoteric languages are here. For more of them you can visit esolangs.org or view the list of some esolangs here . And for a place to run these esoteric languages you can try tio.run","title":"Esoteric Languages"},{"location":"tools%20and%20commands/#brainfuck","text":"Brainfuck is an esoteric programming language created in 1993 by Urban M\u00fcller. Notable for its extreme minimalism, the language consists of only eight simple commands, a data pointer and an instruction pointer. While it is fully Turing complete, it is not intended for practical use, but to challenge and amuse programmers. Brainfuck simply requires one to break commands into microscopic steps. It's common to use brainfuck in CTF challenges. Hello world in brainfuck will look like: >++++++++[<+++++++++>-]<.>++++[<+++++++>-]<+.+++++++..+++.>>++++++[<+++++++>-]<+ +.------------.>++++++[<+++++++++>-]<+.<.+++.------.--------.>>>++++[<++++++++>- ]<+. More Info Interpreter","title":"Brainfuck"},{"location":"tools%20and%20commands/#malbolge","text":"Malbolge is a public domain esoteric programming language invented by Ben Olmstead in 1998, named after the eighth circle of hell in Dante's Inferno, the Malebolge. It was specifically designed to be almost impossible to use, via a counter-intuitive 'crazy operation', base-three arithmetic, and self-altering code. It's common to misunderstand malbolge as base85 or rot47 Hello world in malbolge will look like: (=<`#9]~6ZY32Vx/4Rs+0No-&Jk)\"Fh}|Bcy?`=*z]Kw%oG4UUS0/@-ejc(:'8dc More Info Interpreter","title":"Malbolge"},{"location":"tools%20and%20commands/#piet","text":"Piet is a language designed by David Morgan-Mar, whose programs are bitmaps that look like abstract art. The compilation is guided by a \"pointer\" that moves around the image, from one continuous coloured region to the next. Procedures are carried through when the pointer exits a region. Hello world in Piet will look like: More Info Interpreter","title":"Piet"},{"location":"winja%20ctf/","text":"Winja CTF Writeup Cryptography Esoteric Flag: flag{es2o@t$e4r&i#c_code-most_difficult_to_program} We were given with the text D'`A^?]nIYXWE16Tvus1NpL-KlIH\"hgDB{SRba=<)sxqYonsrqj0hPlkdcb(`Hd]#a`_A@VzZY;Qu87MqQP2HlLEiCHG@EDCBA:^!=6543Wx654-Q1qpM'&+*#G'&}|#z@~}_uts9ZYutslqpi/mlNMiha'_d]ba`_^W{[TYXWVOTSLp32HGLKDhBAF?>b%A:?87[543870T.-2+0)Mnm+$H(hg%${zy?}_{t:rq7otmrkj0ngledc)JIedcb[!B^]\\UyYXWVU7Mqp3INMLEJCgGFE'=<A@?8\\<;4z2V6/4-Q10po'&%I)('g%|{\"!x>|{zsxwp6tmrqpi/POkjib(fe^F\\\"`Y^W{>=YXQu8TMLQPOHlLEJCBAeEDC<;:?8\\<;{z8765.R2r*)(L9 I recognized it is malbolge esolang because I have seen this in some other CTFs. So I ran it in an online interpreter for malbolge and got the flag. Steganography Believe Your Eyes Flag: flag{849d97fa58871dad45e81027f861739_maYB3_i_SHOULd_BELIeve-7HeM} In the site for the challenge, I found this image: So I ran some basic tools like strings and exiftool . When I inspected results got from the exiftool I found the flag in the layers like flag{849d97fa58871dad4, _SHOULd_BELIeve-7HeM}, 5e81027f861739_maYB3_i . But, they weren't in order so I reordered them and found the flag. Hardy Flag: flag{Di77icu8tyI9now@!!#-Youdidit!!} Encoded text given with the challenge This one was not so hard. It was just ciphers inside ciphers. Here is the order of the ciphers: Base58 Morse Code Binary Decimal to ASCII And here is the process in cyberchef. Forensics Anonymous Flag: flag{LJryyYW8IbxuZrOcZ4nd-this-is-a-challenge} In this challenge, you will get a zip file with someone's desktop files inside. So first i tried to find any suspicious files in the folders of the user crazy_crocodile . So first I checked what files are there in the common directories like Picture/ , Documents/ , Music/ , Downloads/ , etc. But there wasn't any files in any of those directories. Then I tried to list all of the hidden directories and found .config/ directory which contained configuration files for google chrome. So I tried to look for any useful files there and I found the History file in the Defaults/ folder in the google chrome folder. So I tried cat History and found a google docs link. I tried visiting the link and tried to submit the title of the file wrapped with flag{} as the flag and it was right! Web b74ass Flag: flag{D@i7s#o89!0@v&e@_php_master} I poked around the website for some times and found that if we supply ?debug in the URL, we would get the source code of the project. And there I found that we need to make the variable final_string to roseytherehappy in order to get the flag. But, the PHP code removes every occurrence of roseytherehappy with function preg_replace . So how do we solve it? Well, the preg_replace replaces exact word with nothing. So we could insert a roseytherehappy inside any of the letters in the roseytherehappy and it will replace it, and we will get the roseytherehappy as value. So the payload will look like roseytherehapproseytherehappyy . And the final URL will look like: https://jerry.winja.site/?value=roseytherehapproseytherehappyy","title":"Winja CTF"},{"location":"winja%20ctf/#winja-ctf-writeup","text":"","title":"Winja CTF Writeup"},{"location":"winja%20ctf/#cryptography","text":"","title":"Cryptography"},{"location":"winja%20ctf/#esoteric","text":"Flag: flag{es2o@t$e4r&i#c_code-most_difficult_to_program} We were given with the text D'`A^?]nIYXWE16Tvus1NpL-KlIH\"hgDB{SRba=<)sxqYonsrqj0hPlkdcb(`Hd]#a`_A@VzZY;Qu87MqQP2HlLEiCHG@EDCBA:^!=6543Wx654-Q1qpM'&+*#G'&}|#z@~}_uts9ZYutslqpi/mlNMiha'_d]ba`_^W{[TYXWVOTSLp32HGLKDhBAF?>b%A:?87[543870T.-2+0)Mnm+$H(hg%${zy?}_{t:rq7otmrkj0ngledc)JIedcb[!B^]\\UyYXWVU7Mqp3INMLEJCgGFE'=<A@?8\\<;4z2V6/4-Q10po'&%I)('g%|{\"!x>|{zsxwp6tmrqpi/POkjib(fe^F\\\"`Y^W{>=YXQu8TMLQPOHlLEJCBAeEDC<;:?8\\<;{z8765.R2r*)(L9 I recognized it is malbolge esolang because I have seen this in some other CTFs. So I ran it in an online interpreter for malbolge and got the flag.","title":"Esoteric"},{"location":"winja%20ctf/#steganography","text":"","title":"Steganography"},{"location":"winja%20ctf/#believe-your-eyes","text":"Flag: flag{849d97fa58871dad45e81027f861739_maYB3_i_SHOULd_BELIeve-7HeM} In the site for the challenge, I found this image: So I ran some basic tools like strings and exiftool . When I inspected results got from the exiftool I found the flag in the layers like flag{849d97fa58871dad4, _SHOULd_BELIeve-7HeM}, 5e81027f861739_maYB3_i . But, they weren't in order so I reordered them and found the flag.","title":"Believe Your Eyes"},{"location":"winja%20ctf/#hardy","text":"Flag: flag{Di77icu8tyI9now@!!#-Youdidit!!} Encoded text given with the challenge This one was not so hard. It was just ciphers inside ciphers. Here is the order of the ciphers: Base58 Morse Code Binary Decimal to ASCII And here is the process in cyberchef.","title":"Hardy"},{"location":"winja%20ctf/#forensics","text":"","title":"Forensics"},{"location":"winja%20ctf/#anonymous","text":"Flag: flag{LJryyYW8IbxuZrOcZ4nd-this-is-a-challenge} In this challenge, you will get a zip file with someone's desktop files inside. So first i tried to find any suspicious files in the folders of the user crazy_crocodile . So first I checked what files are there in the common directories like Picture/ , Documents/ , Music/ , Downloads/ , etc. But there wasn't any files in any of those directories. Then I tried to list all of the hidden directories and found .config/ directory which contained configuration files for google chrome. So I tried to look for any useful files there and I found the History file in the Defaults/ folder in the google chrome folder. So I tried cat History and found a google docs link. I tried visiting the link and tried to submit the title of the file wrapped with flag{} as the flag and it was right!","title":"Anonymous"},{"location":"winja%20ctf/#web","text":"","title":"Web"},{"location":"winja%20ctf/#b74ass","text":"Flag: flag{D@i7s#o89!0@v&e@_php_master} I poked around the website for some times and found that if we supply ?debug in the URL, we would get the source code of the project. And there I found that we need to make the variable final_string to roseytherehappy in order to get the flag. But, the PHP code removes every occurrence of roseytherehappy with function preg_replace . So how do we solve it? Well, the preg_replace replaces exact word with nothing. So we could insert a roseytherehappy inside any of the letters in the roseytherehappy and it will replace it, and we will get the roseytherehappy as value. So the payload will look like roseytherehapproseytherehappyy . And the final URL will look like: https://jerry.winja.site/?value=roseytherehapproseytherehappyy","title":"b74ass"}]}