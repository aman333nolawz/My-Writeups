{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is this? This is my writeups for different CTFs i have participated","title":"What is this?"},{"location":"#what-is-this","text":"This is my writeups for different CTFs i have participated","title":"What is this?"},{"location":"fweefwop/","text":"Fweefwop CTF Writeup Crypto Silly Secret Sharing Flag: 84333 For this challenge I read a article in wikipedia and took a code from there, and then modified the code a bit and ran it. And tada! you get the flag! Wikipedia article on Shamir's Secret Sharing Here's the code: _PRIME = 2 ** 127 - 1 def _extended_gcd ( a , b ): \"\"\" Division in integers modulus p means finding the inverse of the denominator modulo p and then multiplying the numerator by this inverse (Note: inverse of A is B such that A*B % p == 1) this can be computed via extended Euclidean algorithm http://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Computation \"\"\" x = 0 last_x = 1 y = 1 last_y = 0 while b != 0 : quot = a // b a , b = b , a % b x , last_x = last_x - quot * x , x y , last_y = last_y - quot * y , y return last_x , last_y def _divmod ( num , den , p ): \"\"\"Compute num / den modulo prime p To explain what this means, the return value will be such that the following is true: den * _divmod(num, den, p) % p == num \"\"\" inv , _ = _extended_gcd ( den , p ) return num * inv def _lagrange_interpolate ( x , x_s , y_s , p ): \"\"\" Find the y-value for the given x, given n (x, y) points; k points will define a polynomial of up to kth order. \"\"\" k = len ( x_s ) assert k == len ( set ( x_s )), \"points must be distinct\" def PI ( vals ): # upper-case PI -- product of inputs accum = 1 for v in vals : accum *= v return accum nums = [] # avoid inexact division dens = [] for i in range ( k ): others = list ( x_s ) cur = others . pop ( i ) nums . append ( PI ( x - o for o in others )) dens . append ( PI ( cur - o for o in others )) den = PI ( dens ) num = sum ([ _divmod ( nums [ i ] * den * y_s [ i ] % p , dens [ i ], p ) for i in range ( k )]) return ( _divmod ( num , den , p ) + p ) % p def recover_secret ( shares , prime = _PRIME ): \"\"\" Recover the secret from share points (x, y points on the polynomial). \"\"\" if len ( shares ) < 2 : raise ValueError ( \"need at least two shares\" ) x_s , y_s = zip ( * shares ) return _lagrange_interpolate ( 0 , x_s , y_s , prime ) shares = [( 20 , 161013 ), ( 10 , 122673 )] print ( recover_secret ( shares )) Open Secret Flag: fwopCTF{I_found_the_alien_his_name_is_paul} So first I read this article on Wikipedia about Diffie Hellman Key exchange. Then I calculated s and xored base64 decoded flag with the key as bytes represantation of s . Here's the code: from Crypto.Util.number import long_to_bytes import base64 from pwn import xor p = 824717393 g = 150357959 A = 734947628 b = 845023462 B = pow ( g , b , p ) s = pow ( A , b , p ) flag = 'T6ZBVGqFaF9gjkhLXL9Ke125S3tIvUdBR45GTVqOQEVEtHFNWo5eRVy9Uw==' print ( xor ( base64 . b64decode ( flag ), long_to_bytes ( s ))) Pretty Safe Password Flag: fwopCTF{pa55word} For this challenge I wrapped all of the passwords with fwopCTF{} in sublime text. Then I ran John the ripper on the hash using the following command: $ john hash.txt --wordlist = 10k-most-common.txt --format = Raw-MD5 Web SQLI Flag: fwopCTF{Leaked_data_123} This challenge was just a basic SQL injection. I got the flag by just passing ' OR 1=1 -- as both password and username. SQLI But Filtered? Flag: fwopCTF{f1lt3rs_not_good_3n0ugh} This challenge is just advanced version of the SQLI Challenge. So First I tried the payload on that challenge but it didn't work. So I tried more of them and finally the ' || '1'='1 as admin and password got me the flag. Reversing Reversing Python 7 Flag: its_time_t;qfwopCTF{ Code which we need to reverse: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () semicolonpos = 0 fail = False if len ( enteredFlag ) != 20 : print ( \"Your flag is incorrect. :(\" ) else : enteredFlag = enteredFlag [ 12 : 20 ] + enteredFlag [ 0 : 12 ] for i in range ( 20 ): if enteredFlag [ i ] == \";\" : semicolonpos = i elif enteredFlag [ i ] == \"q\" : break ; else : fail = True if not fail : enteredFlag = enteredFlag [ 0 : semicolonpos ] + \"o_dddduel}\" if enteredFlag == \"fwopCTF {its_time_to_dddduel} \" : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So first of all we can see the that they are adding o_dddduel} to the flag. So the first part of the flag will be fwopCTF{its_time_t . Then we can see that it removes the semi colon from the entered input. so we can add that and now the flag will look lik fwopCTF{its_time_; . And if let's take a look at the for loop. We can see that it will break if the letter q is occured. So we now can add that also, and the flag will be fwopCTF{its_time_;q . and the final step is to shuffle them. So to reverse that we can use string splicing in python. Using the python code flag[8:]+flag[:8] we can see that the flag will be its_time_t;qfwopCTF{ and that's it we got the flag! Here's the code for that: # The flag checked in the if statement flag = \"fwopCTF {its_time_to_dddduel} \" # Where the semicolon was semicolonpos = 18 # Cut upto the semicolon and then add the semicolon and q flag = flag [ 0 : semicolonpos ] + \";q\" # Now shuffle it shuffled_flag = flag [ 8 :] + flag [: 8 ] # And finally print wthe result print ( shuffled_flag )","title":"Fweefwop CTF"},{"location":"fweefwop/#fweefwop-ctf-writeup","text":"","title":"Fweefwop CTF Writeup"},{"location":"fweefwop/#crypto","text":"","title":"Crypto"},{"location":"fweefwop/#silly-secret-sharing","text":"Flag: 84333 For this challenge I read a article in wikipedia and took a code from there, and then modified the code a bit and ran it. And tada! you get the flag! Wikipedia article on Shamir's Secret Sharing Here's the code: _PRIME = 2 ** 127 - 1 def _extended_gcd ( a , b ): \"\"\" Division in integers modulus p means finding the inverse of the denominator modulo p and then multiplying the numerator by this inverse (Note: inverse of A is B such that A*B % p == 1) this can be computed via extended Euclidean algorithm http://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Computation \"\"\" x = 0 last_x = 1 y = 1 last_y = 0 while b != 0 : quot = a // b a , b = b , a % b x , last_x = last_x - quot * x , x y , last_y = last_y - quot * y , y return last_x , last_y def _divmod ( num , den , p ): \"\"\"Compute num / den modulo prime p To explain what this means, the return value will be such that the following is true: den * _divmod(num, den, p) % p == num \"\"\" inv , _ = _extended_gcd ( den , p ) return num * inv def _lagrange_interpolate ( x , x_s , y_s , p ): \"\"\" Find the y-value for the given x, given n (x, y) points; k points will define a polynomial of up to kth order. \"\"\" k = len ( x_s ) assert k == len ( set ( x_s )), \"points must be distinct\" def PI ( vals ): # upper-case PI -- product of inputs accum = 1 for v in vals : accum *= v return accum nums = [] # avoid inexact division dens = [] for i in range ( k ): others = list ( x_s ) cur = others . pop ( i ) nums . append ( PI ( x - o for o in others )) dens . append ( PI ( cur - o for o in others )) den = PI ( dens ) num = sum ([ _divmod ( nums [ i ] * den * y_s [ i ] % p , dens [ i ], p ) for i in range ( k )]) return ( _divmod ( num , den , p ) + p ) % p def recover_secret ( shares , prime = _PRIME ): \"\"\" Recover the secret from share points (x, y points on the polynomial). \"\"\" if len ( shares ) < 2 : raise ValueError ( \"need at least two shares\" ) x_s , y_s = zip ( * shares ) return _lagrange_interpolate ( 0 , x_s , y_s , prime ) shares = [( 20 , 161013 ), ( 10 , 122673 )] print ( recover_secret ( shares ))","title":"Silly Secret Sharing"},{"location":"fweefwop/#open-secret","text":"Flag: fwopCTF{I_found_the_alien_his_name_is_paul} So first I read this article on Wikipedia about Diffie Hellman Key exchange. Then I calculated s and xored base64 decoded flag with the key as bytes represantation of s . Here's the code: from Crypto.Util.number import long_to_bytes import base64 from pwn import xor p = 824717393 g = 150357959 A = 734947628 b = 845023462 B = pow ( g , b , p ) s = pow ( A , b , p ) flag = 'T6ZBVGqFaF9gjkhLXL9Ke125S3tIvUdBR45GTVqOQEVEtHFNWo5eRVy9Uw==' print ( xor ( base64 . b64decode ( flag ), long_to_bytes ( s )))","title":"Open Secret"},{"location":"fweefwop/#pretty-safe-password","text":"Flag: fwopCTF{pa55word} For this challenge I wrapped all of the passwords with fwopCTF{} in sublime text. Then I ran John the ripper on the hash using the following command: $ john hash.txt --wordlist = 10k-most-common.txt --format = Raw-MD5","title":"Pretty Safe Password"},{"location":"fweefwop/#web","text":"","title":"Web"},{"location":"fweefwop/#sqli","text":"Flag: fwopCTF{Leaked_data_123} This challenge was just a basic SQL injection. I got the flag by just passing ' OR 1=1 -- as both password and username.","title":"SQLI"},{"location":"fweefwop/#sqli-but-filtered","text":"Flag: fwopCTF{f1lt3rs_not_good_3n0ugh} This challenge is just advanced version of the SQLI Challenge. So First I tried the payload on that challenge but it didn't work. So I tried more of them and finally the ' || '1'='1 as admin and password got me the flag.","title":"SQLI But Filtered?"},{"location":"fweefwop/#reversing","text":"","title":"Reversing"},{"location":"fweefwop/#reversing-python-7","text":"Flag: its_time_t;qfwopCTF{ Code which we need to reverse: print ( \"Enter the flag and I will check it for you.\" ) enteredFlag = input () semicolonpos = 0 fail = False if len ( enteredFlag ) != 20 : print ( \"Your flag is incorrect. :(\" ) else : enteredFlag = enteredFlag [ 12 : 20 ] + enteredFlag [ 0 : 12 ] for i in range ( 20 ): if enteredFlag [ i ] == \";\" : semicolonpos = i elif enteredFlag [ i ] == \"q\" : break ; else : fail = True if not fail : enteredFlag = enteredFlag [ 0 : semicolonpos ] + \"o_dddduel}\" if enteredFlag == \"fwopCTF {its_time_to_dddduel} \" : print ( \"Your flag is correct!\" ) else : print ( \"Your flag is incorrect. :(\" ) So first of all we can see the that they are adding o_dddduel} to the flag. So the first part of the flag will be fwopCTF{its_time_t . Then we can see that it removes the semi colon from the entered input. so we can add that and now the flag will look lik fwopCTF{its_time_; . And if let's take a look at the for loop. We can see that it will break if the letter q is occured. So we now can add that also, and the flag will be fwopCTF{its_time_;q . and the final step is to shuffle them. So to reverse that we can use string splicing in python. Using the python code flag[8:]+flag[:8] we can see that the flag will be its_time_t;qfwopCTF{ and that's it we got the flag! Here's the code for that: # The flag checked in the if statement flag = \"fwopCTF {its_time_to_dddduel} \" # Where the semicolon was semicolonpos = 18 # Cut upto the semicolon and then add the semicolon and q flag = flag [ 0 : semicolonpos ] + \";q\" # Now shuffle it shuffled_flag = flag [ 8 :] + flag [: 8 ] # And finally print wthe result print ( shuffled_flag )","title":"Reversing Python 7"}]}